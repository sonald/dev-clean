use crate::config::{CustomPattern, MarkerMode};
use globset::GlobBuilder;
use ignore::gitignore::GitignoreBuilder;
use ignore::Match;
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;

/// Supported project types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ProjectType {
    NodeJs,
    Rust,
    Python,
    Java,
    Kotlin,
    Scala,
    Clojure,
    Dart,
    Haskell,
    Go,
    C,
    Cpp,
    Ruby,
    Swift,
    Php,
    Elixir,
    DotNet,
    Maven,
    Gradle,
    Generic,
}

impl ProjectType {
    /// Returns the color code for CLI display
    pub fn color(&self) -> &'static str {
        match self {
            Self::NodeJs => "green",
            Self::Rust => "red",
            Self::Python => "blue",
            Self::Java | Self::Kotlin | Self::Maven | Self::Gradle => "cyan",
            Self::Scala => "red",
            Self::Clojure => "cyan",
            Self::Dart => "blue",
            Self::Haskell => "yellow",
            Self::Go => "cyan",
            Self::Ruby => "red",
            Self::Swift => "yellow",
            Self::Php => "magenta",
            Self::Elixir => "magenta",
            Self::DotNet => "blue",
            _ => "white",
        }
    }

    /// Returns the display name
    pub fn name(&self) -> &'static str {
        match self {
            Self::NodeJs => "Node.js",
            Self::Rust => "Rust",
            Self::Python => "Python",
            Self::Java => "Java",
            Self::Kotlin => "Kotlin",
            Self::Scala => "Scala",
            Self::Clojure => "Clojure",
            Self::Dart => "Dart",
            Self::Haskell => "Haskell",
            Self::Go => "Go",
            Self::C => "C",
            Self::Cpp => "C++",
            Self::Ruby => "Ruby",
            Self::Swift => "Swift",
            Self::Php => "PHP",
            Self::Elixir => "Elixir",
            Self::DotNet => ".NET",
            Self::Maven => "Maven",
            Self::Gradle => "Gradle",
            Self::Generic => "Generic",
        }
    }
}

/// Project type detector
pub struct ProjectDetector;

impl ProjectDetector {
    /// Detect project type by checking marker files
    pub fn detect(dir: &Path) -> Option<ProjectType> {
        if dir.join("package.json").exists() || dir.join("package-lock.json").exists() {
            return Some(ProjectType::NodeJs);
        }

        if dir.join("Cargo.toml").exists() {
            return Some(ProjectType::Rust);
        }

        if dir.join("requirements.txt").exists()
            || dir.join("setup.py").exists()
            || dir.join("pyproject.toml").exists()
            || dir.join("Pipfile").exists()
        {
            return Some(ProjectType::Python);
        }

        if dir.join("pom.xml").exists() {
            return Some(ProjectType::Maven);
        }

        if dir.join("build.gradle").exists() || dir.join("build.gradle.kts").exists() {
            return Some(ProjectType::Gradle);
        }

        if dir.join("build.sbt").exists() {
            return Some(ProjectType::Scala);
        }

        if dir.join("project.clj").exists() || dir.join("deps.edn").exists() {
            return Some(ProjectType::Clojure);
        }

        if dir.join("pubspec.yaml").exists() {
            return Some(ProjectType::Dart);
        }

        if dir.join("stack.yaml").exists() || dir_contains_extension(dir, &["cabal"]) {
            return Some(ProjectType::Haskell);
        }

        if dir.join("go.mod").exists() {
            return Some(ProjectType::Go);
        }

        if dir.join("Gemfile").exists() {
            return Some(ProjectType::Ruby);
        }

        if dir.join("Package.swift").exists() {
            return Some(ProjectType::Swift);
        }

        if dir.join("composer.json").exists() {
            return Some(ProjectType::Php);
        }

        if dir.join("mix.exs").exists() {
            return Some(ProjectType::Elixir);
        }

        if dir_contains_extension(dir, &["csproj", "sln"]) {
            return Some(ProjectType::DotNet);
        }

        if dir.join("CMakeLists.txt").exists() || dir.join("Makefile").exists() {
            // Could be C or C++, default to C++
            return Some(ProjectType::Cpp);
        }

        None
    }

    /// Check if a directory is a CMake build directory (out-of-source build)
    ///
    /// This uses heuristic detection by checking for CMakeCache.txt, which is
    /// generated by CMake during configuration and only exists in build directories.
    ///
    /// Safety: Returns false if the directory also contains CMakeLists.txt, which
    /// indicates an in-source build where source code and build artifacts are mixed.
    /// We must NOT delete such directories as they contain source code.
    ///
    /// # Arguments
    /// * `dir` - The directory to check
    ///
    /// # Returns
    /// * `true` - Safe to delete (out-of-source build directory)
    /// * `false` - Not a build directory, or in-source build (unsafe to delete)
    pub fn is_cmake_build_dir(dir: &Path) -> bool {
        // Optimize for the common case: most directories don't have a CMake cache.
        if !dir.join("CMakeCache.txt").exists() {
            return false;
        }

        // Safety: Only pure build directories are safe to delete (cache present, no source).
        !dir.join("CMakeLists.txt").exists()
    }

    /// Get cleanable directories for a project type
    pub fn cleanable_dirs(project_type: ProjectType) -> Vec<&'static str> {
        match project_type {
            ProjectType::NodeJs => vec![
                "node_modules",
                ".next",
                ".nuxt",
                "dist",
                "build",
                ".cache",
                ".turbo",
                ".parcel-cache",
            ],
            ProjectType::Rust => vec!["target"],
            ProjectType::Python => vec![
                ".venv",
                "venv",
                "__pycache__",
                ".pytest_cache",
                ".mypy_cache",
                ".tox",
                "*.egg-info",
                ".eggs",
                "build",
                "dist",
            ],
            ProjectType::Java | ProjectType::Maven => vec!["target", "out"],
            ProjectType::Kotlin | ProjectType::Gradle => vec!["build", ".gradle", "out"],
            ProjectType::Scala => vec!["target", "project/target"],
            ProjectType::Clojure => vec!["target"],
            ProjectType::Dart => vec!["build", ".dart_tool"],
            ProjectType::Haskell => vec!["dist", "dist-newstyle", ".stack-work"],
            ProjectType::Go => vec!["vendor", "bin"],
            ProjectType::C | ProjectType::Cpp => {
                vec!["build", "cmake-build-debug", "cmake-build-release", "out"]
            }
            ProjectType::Ruby => vec!["vendor/bundle", ".bundle"],
            ProjectType::Swift => vec![".build", "DerivedData", ".swiftpm"],
            ProjectType::Php => vec!["vendor"],
            ProjectType::Elixir => vec!["_build", "deps"],
            ProjectType::DotNet => vec!["bin", "obj"],
            ProjectType::Generic => vec![],
        }
    }

    /// Check if a directory is currently in use based on lock files
    pub fn is_in_use(project_dir: &Path, project_type: ProjectType) -> bool {
        match project_type {
            ProjectType::NodeJs => {
                // Check if package-lock.json or yarn.lock was recently modified
                let lock_files = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];
                Self::check_recent_lock_files(project_dir, &lock_files)
            }
            ProjectType::Rust => Self::check_recent_lock_files(project_dir, &["Cargo.lock"]),
            ProjectType::Python => {
                Self::check_recent_lock_files(project_dir, &["Pipfile.lock", "poetry.lock"])
            }
            ProjectType::Dart => Self::check_recent_lock_files(project_dir, &["pubspec.lock"]),
            ProjectType::Haskell => {
                Self::check_recent_lock_files(project_dir, &["stack.yaml.lock"])
            }
            ProjectType::Go => Self::check_recent_lock_files(project_dir, &["go.sum"]),
            ProjectType::Ruby => Self::check_recent_lock_files(project_dir, &["Gemfile.lock"]),
            ProjectType::Php => Self::check_recent_lock_files(project_dir, &["composer.lock"]),
            _ => false,
        }
    }

    fn check_recent_lock_files(dir: &Path, lock_files: &[&str]) -> bool {
        use std::time::{Duration, SystemTime};

        for lock_file in lock_files {
            if let Ok(metadata) = dir.join(lock_file).metadata() {
                if let Ok(modified) = metadata.modified() {
                    if let Ok(elapsed) = SystemTime::now().duration_since(modified) {
                        // Consider in use if modified within last 7 days
                        if elapsed < Duration::from_secs(7 * 24 * 60 * 60) {
                            return true;
                        }
                    }
                }
            }
        }
        false
    }

    /// Parse .gitignore file and extract potential cleanable directory patterns
    pub fn parse_gitignore(project_dir: &Path) -> Vec<String> {
        let gitignore_path = project_dir.join(".gitignore");

        if !gitignore_path.exists() {
            return Vec::new();
        }

        let content = match fs::read_to_string(&gitignore_path) {
            Ok(c) => c,
            Err(_) => return Vec::new(),
        };

        let mut cleanable_patterns = Vec::new();

        for line in content.lines() {
            if let Some(pattern) = Self::gitignore_discovery_pattern(line) {
                cleanable_patterns.push(pattern);
            }
        }

        cleanable_patterns
    }

    pub(crate) fn gitignore_discovery_pattern(line: &str) -> Option<String> {
        let line = line.trim();

        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('#') {
            return None;
        }

        // Skip negation patterns (starting with !)
        if line.starts_with('!') {
            return None;
        }

        // Skip file patterns (contains extension or is clearly a file)
        if line.contains('.') && !line.ends_with('/') && !line.starts_with('.') {
            // This might be a file pattern like *.log, skip it
            return None;
        }

        // Clean up the pattern
        let mut pattern = line.to_string();

        // Remove leading slash
        if pattern.starts_with('/') {
            pattern = pattern[1..].to_string();
        }

        // Remove trailing slash
        if pattern.ends_with('/') {
            pattern = pattern[..pattern.len() - 1].to_string();
        }

        // Skip patterns with wildcards in the middle (too complex)
        if pattern.contains('*') && !pattern.starts_with('*') && !pattern.ends_with('*') {
            return None;
        }

        // Skip obviously protected directories
        if matches!(
            pattern.as_str(),
            ".git" | ".svn" | ".hg" | "." | ".." | "src" | "lib" | "include"
        ) {
            return None;
        }

        // Skip common file patterns (even if they start with .)
        if matches!(
            pattern.as_str(),
            ".env"
                | ".DS_Store"
                | ".gitignore"
                | ".gitattributes"
                | ".editorconfig"
                | ".npmrc"
                | ".yarnrc"
        ) {
            return None;
        }

        // Only include patterns that look like directories
        // Typically: no extension, or starts with . (hidden dirs)
        if !pattern.is_empty() && (pattern.starts_with('.') || !pattern.contains('.')) {
            return Some(pattern);
        }

        None
    }

    /// Get cleanable directories including both default patterns and .gitignore patterns
    pub fn cleanable_dirs_with_gitignore(
        project_type: ProjectType,
        project_dir: &Path,
    ) -> Vec<String> {
        let mut cleanable = Self::cleanable_dirs(project_type)
            .iter()
            .map(|s| s.to_string())
            .collect::<Vec<String>>();

        // Add patterns from .gitignore
        let gitignore_patterns = Self::parse_gitignore(project_dir);

        for pattern in gitignore_patterns {
            // Only add if not already in the list
            if !cleanable.contains(&pattern) {
                cleanable.push(pattern);
            }
        }

        cleanable
    }

    /// Explain why a directory is considered cleanable.
    ///
    /// This is primarily intended for CLI output (`scan --explain`).
    pub fn explain_cleanable_dir(
        project_type: ProjectType,
        project_root: &Path,
        cleanable_dir: &Path,
        custom_patterns: &[CustomPattern],
    ) -> String {
        let basename = cleanable_dir
            .file_name()
            .and_then(|s| s.to_str())
            .unwrap_or_default();

        let relative_path = cleanable_dir
            .strip_prefix(project_root)
            .ok()
            .map(|p| p.to_string_lossy().replace('\\', "/"))
            .unwrap_or_else(|| cleanable_dir.display().to_string());

        // Prefer user config custom patterns.
        for pattern in custom_patterns {
            if !custom_root_matches(project_root, pattern) {
                continue;
            }
            if pattern_matches(&pattern.directory, basename, &relative_path) {
                return format!(
                    "matched config custom pattern `{}` directory `{}`",
                    pattern.name, pattern.directory
                );
            }
        }

        // Then built-in patterns.
        for pattern in Self::cleanable_dirs(project_type) {
            if pattern_matches(pattern, basename, &relative_path) {
                return format!("matched builtin pattern `{}`", pattern);
            }
        }

        // Then `.gitignore`-derived patterns (conservative discovery).
        if let Some(pattern) = explain_gitignore_discovery_pattern(project_root, cleanable_dir) {
            return format!("matched .gitignore pattern `{}`", pattern);
        }

        // Finally, heuristics.
        if Self::is_cmake_build_dir(cleanable_dir) {
            return "matched CMake out-of-source build heuristic (CMakeCache.txt present, no CMakeLists.txt)".to_string();
        }

        "matched cleanable rules".to_string()
    }
}

fn explain_gitignore_discovery_pattern(project_root: &Path, dir: &Path) -> Option<String> {
    let mut builder = GitignoreBuilder::new(project_root);
    let path = project_root.join(".gitignore");
    if !path.is_file() {
        return None;
    }
    let _ = builder.add(path);
    let gi = builder.build().ok()?;
    match gi.matched(dir, /* is_dir */ true) {
        Match::Ignore(glob) => ProjectDetector::gitignore_discovery_pattern(glob.original()),
        Match::None | Match::Whitelist(_) => None,
    }
}

fn pattern_matches(pattern: &str, basename: &str, relative_path: &str) -> bool {
    let pattern = pattern.replace('\\', "/");
    let text = if pattern.contains('/') {
        relative_path
    } else {
        basename
    };

    let glob = match GlobBuilder::new(&pattern).literal_separator(true).build() {
        Ok(g) => g,
        Err(_) => return false,
    };

    glob.compile_matcher().is_match(text)
}

fn custom_root_matches(project_root: &Path, custom: &CustomPattern) -> bool {
    if custom.marker_files.is_empty() {
        return false;
    }

    match custom.marker_mode {
        MarkerMode::AnyOf => custom
            .marker_files
            .iter()
            .any(|marker| project_root.join(marker).exists()),
        MarkerMode::AllOf => custom
            .marker_files
            .iter()
            .all(|marker| project_root.join(marker).exists()),
    }
}

fn dir_contains_extension(dir: &Path, extensions: &[&str]) -> bool {
    let entries = match fs::read_dir(dir) {
        Ok(e) => e,
        Err(_) => return false,
    };

    for entry in entries.flatten() {
        let path = entry.path();
        if !path.is_file() {
            continue;
        }
        let Some(ext) = path.extension().and_then(|e| e.to_str()) else {
            continue;
        };
        if extensions
            .iter()
            .any(|candidate| ext.eq_ignore_ascii_case(candidate))
        {
            return true;
        }
    }

    false
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_detect_dotnet_project() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path();

        fs::write(dir.join("app.csproj"), "<Project></Project>").unwrap();
        assert_eq!(ProjectDetector::detect(dir), Some(ProjectType::DotNet));
    }

    #[test]
    fn test_detect_scala_project() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path();

        fs::write(dir.join("build.sbt"), "name := \"demo\"").unwrap();
        assert_eq!(ProjectDetector::detect(dir), Some(ProjectType::Scala));
    }

    #[test]
    fn test_detect_clojure_project() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path();

        fs::write(dir.join("deps.edn"), "{:deps {}}").unwrap();
        assert_eq!(ProjectDetector::detect(dir), Some(ProjectType::Clojure));
    }

    #[test]
    fn test_detect_dart_project() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path();

        fs::write(dir.join("pubspec.yaml"), "name: demo").unwrap();
        assert_eq!(ProjectDetector::detect(dir), Some(ProjectType::Dart));
    }

    #[test]
    fn test_detect_haskell_project() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path();

        fs::write(dir.join("demo.cabal"), "name: demo").unwrap();
        assert_eq!(ProjectDetector::detect(dir), Some(ProjectType::Haskell));
    }

    #[test]
    fn test_parse_gitignore() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        // Create a .gitignore file
        let gitignore_content = r#"
# Node dependencies
node_modules/
dist/

# Cache directories
.cache/
.temp

# Files (should be skipped)
*.log
.env

# Protected dirs (should be skipped)
.git/
src/

# Complex patterns (should be skipped)
**/temp/*
"#;
        fs::write(project_dir.join(".gitignore"), gitignore_content).unwrap();

        let patterns = ProjectDetector::parse_gitignore(project_dir);

        // Should include directory patterns
        assert!(patterns.contains(&"node_modules".to_string()));
        assert!(patterns.contains(&"dist".to_string()));
        assert!(patterns.contains(&".cache".to_string()));
        assert!(patterns.contains(&".temp".to_string()));

        // Should NOT include file patterns
        assert!(!patterns.iter().any(|p| p.contains(".log")));
        assert!(!patterns.iter().any(|p| p.contains(".env")));

        // Should NOT include protected directories
        assert!(!patterns.contains(&".git".to_string()));
        assert!(!patterns.contains(&"src".to_string()));
    }

    #[test]
    fn test_cleanable_dirs_with_gitignore() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        // Create a Node.js project
        fs::write(project_dir.join("package.json"), "{}").unwrap();

        // Create a .gitignore with custom patterns
        let gitignore_content = r#"
node_modules/
dist/
.custom-cache/
"#;
        fs::write(project_dir.join(".gitignore"), gitignore_content).unwrap();

        let cleanable =
            ProjectDetector::cleanable_dirs_with_gitignore(ProjectType::NodeJs, project_dir);

        // Should include default Node.js patterns
        assert!(cleanable.iter().any(|d| d == "node_modules"));
        assert!(cleanable.iter().any(|d| d == ".next"));

        // Should also include .gitignore patterns
        assert!(cleanable.iter().any(|d| d == "dist"));
        assert!(cleanable.iter().any(|d| d == ".custom-cache"));
    }

    #[test]
    fn test_parse_gitignore_no_file() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        let patterns = ProjectDetector::parse_gitignore(project_dir);
        assert!(patterns.is_empty());
    }

    #[test]
    fn test_is_cmake_build_dir_out_of_source() {
        let temp = TempDir::new().unwrap();
        let build_dir = temp.path().join("mybuild");
        fs::create_dir(&build_dir).unwrap();

        // Create CMakeCache.txt (build artifact)
        fs::write(build_dir.join("CMakeCache.txt"), "# CMake cache").unwrap();

        // Should be recognized as cleanable build directory
        assert!(ProjectDetector::is_cmake_build_dir(&build_dir));
    }

    #[test]
    fn test_is_cmake_build_dir_in_source() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path().join("myproject");
        fs::create_dir(&project_dir).unwrap();

        // Create both CMakeLists.txt (source) and CMakeCache.txt (build)
        // This indicates in-source build - should NOT be deletable
        fs::write(project_dir.join("CMakeLists.txt"), "project(test)").unwrap();
        fs::write(project_dir.join("CMakeCache.txt"), "# CMake cache").unwrap();

        // Should NOT be recognized as cleanable (source + build mixed)
        assert!(!ProjectDetector::is_cmake_build_dir(&project_dir));
    }

    #[test]
    fn test_is_cmake_build_dir_no_cache() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path().join("somedir");
        fs::create_dir(&dir).unwrap();

        // Directory without CMakeCache.txt
        assert!(!ProjectDetector::is_cmake_build_dir(&dir));
    }

    #[test]
    fn test_is_cmake_build_dir_source_only() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path().join("myproject");
        fs::create_dir(&project_dir).unwrap();

        // Only source file, no build artifacts
        fs::write(project_dir.join("CMakeLists.txt"), "project(test)").unwrap();

        // Should NOT be recognized as cleanable (source only)
        assert!(!ProjectDetector::is_cmake_build_dir(&project_dir));
    }
}
