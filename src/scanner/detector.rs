use std::path::Path;
use std::fs;
use serde::{Serialize, Deserialize};

/// Supported project types
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub enum ProjectType {
    NodeJs,
    Rust,
    Python,
    Java,
    Kotlin,
    Go,
    C,
    Cpp,
    Ruby,
    Swift,
    Php,
    Elixir,
    DotNet,
    Maven,
    Gradle,
    Generic,
}

impl ProjectType {
    /// Returns the color code for CLI display
    pub fn color(&self) -> &'static str {
        match self {
            Self::NodeJs => "green",
            Self::Rust => "red",
            Self::Python => "blue",
            Self::Java | Self::Kotlin | Self::Maven | Self::Gradle => "cyan",
            Self::Go => "cyan",
            Self::Ruby => "red",
            Self::Swift => "yellow",
            Self::Php => "magenta",
            Self::Elixir => "magenta",
            Self::DotNet => "blue",
            _ => "white",
        }
    }

    /// Returns the display name
    pub fn name(&self) -> &'static str {
        match self {
            Self::NodeJs => "Node.js",
            Self::Rust => "Rust",
            Self::Python => "Python",
            Self::Java => "Java",
            Self::Kotlin => "Kotlin",
            Self::Go => "Go",
            Self::C => "C",
            Self::Cpp => "C++",
            Self::Ruby => "Ruby",
            Self::Swift => "Swift",
            Self::Php => "PHP",
            Self::Elixir => "Elixir",
            Self::DotNet => ".NET",
            Self::Maven => "Maven",
            Self::Gradle => "Gradle",
            Self::Generic => "Generic",
        }
    }
}

/// Project type detector
pub struct ProjectDetector;

impl ProjectDetector {
    /// Detect project type by checking marker files
    pub fn detect(dir: &Path) -> Option<ProjectType> {
        if dir.join("package.json").exists() || dir.join("package-lock.json").exists() {
            return Some(ProjectType::NodeJs);
        }

        if dir.join("Cargo.toml").exists() {
            return Some(ProjectType::Rust);
        }

        if dir.join("requirements.txt").exists()
            || dir.join("setup.py").exists()
            || dir.join("pyproject.toml").exists()
            || dir.join("Pipfile").exists() {
            return Some(ProjectType::Python);
        }

        if dir.join("pom.xml").exists() {
            return Some(ProjectType::Maven);
        }

        if dir.join("build.gradle").exists() || dir.join("build.gradle.kts").exists() {
            return Some(ProjectType::Gradle);
        }

        if dir.join("go.mod").exists() {
            return Some(ProjectType::Go);
        }

        if dir.join("Gemfile").exists() {
            return Some(ProjectType::Ruby);
        }

        if dir.join("Package.swift").exists() {
            return Some(ProjectType::Swift);
        }

        if dir.join("composer.json").exists() {
            return Some(ProjectType::Php);
        }

        if dir.join("mix.exs").exists() {
            return Some(ProjectType::Elixir);
        }

        if dir.join("*.csproj").exists() || dir.join("*.sln").exists() {
            return Some(ProjectType::DotNet);
        }

        if dir.join("CMakeLists.txt").exists() || dir.join("Makefile").exists() {
            // Could be C or C++, default to C++
            return Some(ProjectType::Cpp);
        }

        None
    }

    /// Check if a directory is a CMake build directory (out-of-source build)
    ///
    /// This uses heuristic detection by checking for CMakeCache.txt, which is
    /// generated by CMake during configuration and only exists in build directories.
    ///
    /// Safety: Returns false if the directory also contains CMakeLists.txt, which
    /// indicates an in-source build where source code and build artifacts are mixed.
    /// We must NOT delete such directories as they contain source code.
    ///
    /// # Arguments
    /// * `dir` - The directory to check
    ///
    /// # Returns
    /// * `true` - Safe to delete (out-of-source build directory)
    /// * `false` - Not a build directory, or in-source build (unsafe to delete)
    pub fn is_cmake_build_dir(dir: &Path) -> bool {
        let has_cache = dir.join("CMakeCache.txt").exists();
        let has_source = dir.join("CMakeLists.txt").exists();

        // Only pure build directories are safe to delete (has cache but no source)
        has_cache && !has_source
    }

    /// Get cleanable directories for a project type
    pub fn cleanable_dirs(project_type: ProjectType) -> Vec<&'static str> {
        match project_type {
            ProjectType::NodeJs => vec![
                "node_modules",
                ".next",
                ".nuxt",
                "dist",
                "build",
                ".cache",
                ".turbo",
                ".parcel-cache",
            ],
            ProjectType::Rust => vec!["target"],
            ProjectType::Python => vec![
                ".venv",
                "venv",
                "__pycache__",
                ".pytest_cache",
                ".mypy_cache",
                ".tox",
                "*.egg-info",
                ".eggs",
                "build",
                "dist",
            ],
            ProjectType::Java | ProjectType::Maven => vec!["target", "out"],
            ProjectType::Kotlin | ProjectType::Gradle => vec!["build", ".gradle", "out"],
            ProjectType::Go => vec!["vendor", "bin"],
            ProjectType::C | ProjectType::Cpp => vec![
                "build",
                "cmake-build-debug",
                "cmake-build-release",
                "out",
            ],
            ProjectType::Ruby => vec!["vendor/bundle", ".bundle"],
            ProjectType::Swift => vec![".build", "DerivedData", ".swiftpm"],
            ProjectType::Php => vec!["vendor"],
            ProjectType::Elixir => vec!["_build", "deps"],
            ProjectType::DotNet => vec!["bin", "obj"],
            ProjectType::Generic => vec![],
        }
    }

    /// Check if a directory is currently in use based on lock files
    pub fn is_in_use(project_dir: &Path, project_type: ProjectType) -> bool {
        match project_type {
            ProjectType::NodeJs => {
                // Check if package-lock.json or yarn.lock was recently modified
                let lock_files = ["package-lock.json", "yarn.lock", "pnpm-lock.yaml"];
                Self::check_recent_lock_files(project_dir, &lock_files)
            }
            ProjectType::Rust => {
                Self::check_recent_lock_files(project_dir, &["Cargo.lock"])
            }
            ProjectType::Python => {
                Self::check_recent_lock_files(project_dir, &["Pipfile.lock", "poetry.lock"])
            }
            ProjectType::Go => {
                Self::check_recent_lock_files(project_dir, &["go.sum"])
            }
            ProjectType::Ruby => {
                Self::check_recent_lock_files(project_dir, &["Gemfile.lock"])
            }
            ProjectType::Php => {
                Self::check_recent_lock_files(project_dir, &["composer.lock"])
            }
            _ => false,
        }
    }

    fn check_recent_lock_files(dir: &Path, lock_files: &[&str]) -> bool {
        use std::time::{SystemTime, Duration};

        for lock_file in lock_files {
            if let Ok(metadata) = dir.join(lock_file).metadata() {
                if let Ok(modified) = metadata.modified() {
                    if let Ok(elapsed) = SystemTime::now().duration_since(modified) {
                        // Consider in use if modified within last 7 days
                        if elapsed < Duration::from_secs(7 * 24 * 60 * 60) {
                            return true;
                        }
                    }
                }
            }
        }
        false
    }

    /// Parse .gitignore file and extract potential cleanable directory patterns
    pub fn parse_gitignore(project_dir: &Path) -> Vec<String> {
        let gitignore_path = project_dir.join(".gitignore");

        if !gitignore_path.exists() {
            return Vec::new();
        }

        let content = match fs::read_to_string(&gitignore_path) {
            Ok(c) => c,
            Err(_) => return Vec::new(),
        };

        let mut cleanable_patterns = Vec::new();

        for line in content.lines() {
            let line = line.trim();

            // Skip empty lines and comments
            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            // Skip negation patterns (starting with !)
            if line.starts_with('!') {
                continue;
            }

            // Skip file patterns (contains extension or is clearly a file)
            if line.contains('.') && !line.ends_with('/') && !line.starts_with('.') {
                // This might be a file pattern like *.log, skip it
                continue;
            }

            // Clean up the pattern
            let mut pattern = line.to_string();

            // Remove leading slash
            if pattern.starts_with('/') {
                pattern = pattern[1..].to_string();
            }

            // Remove trailing slash
            if pattern.ends_with('/') {
                pattern = pattern[..pattern.len()-1].to_string();
            }

            // Skip patterns with wildcards in the middle (too complex)
            if pattern.contains('*') && !pattern.starts_with('*') && !pattern.ends_with('*') {
                continue;
            }

            // Skip obviously protected directories
            if matches!(pattern.as_str(), ".git" | ".svn" | ".hg" | "." | ".." | "src" | "lib" | "include") {
                continue;
            }

            // Skip common file patterns (even if they start with .)
            if matches!(pattern.as_str(), ".env" | ".DS_Store" | ".gitignore" | ".gitattributes" | ".editorconfig" | ".npmrc" | ".yarnrc") {
                continue;
            }

            // Only include patterns that look like directories
            // Typically: no extension, or starts with . (hidden dirs)
            if !pattern.is_empty() && (pattern.starts_with('.') || !pattern.contains('.')) {
                cleanable_patterns.push(pattern);
            }
        }

        cleanable_patterns
    }

    /// Get cleanable directories including both default patterns and .gitignore patterns
    pub fn cleanable_dirs_with_gitignore(project_type: ProjectType, project_dir: &Path) -> Vec<String> {
        let mut cleanable = Self::cleanable_dirs(project_type)
            .iter()
            .map(|s| s.to_string())
            .collect::<Vec<String>>();

        // Add patterns from .gitignore
        let gitignore_patterns = Self::parse_gitignore(project_dir);

        for pattern in gitignore_patterns {
            // Only add if not already in the list
            if !cleanable.contains(&pattern) {
                cleanable.push(pattern);
            }
        }

        cleanable
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;

    #[test]
    fn test_parse_gitignore() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        // Create a .gitignore file
        let gitignore_content = r#"
# Node dependencies
node_modules/
dist/

# Cache directories
.cache/
.temp

# Files (should be skipped)
*.log
.env

# Protected dirs (should be skipped)
.git/
src/

# Complex patterns (should be skipped)
**/temp/*
"#;
        fs::write(project_dir.join(".gitignore"), gitignore_content).unwrap();

        let patterns = ProjectDetector::parse_gitignore(project_dir);

        // Should include directory patterns
        assert!(patterns.contains(&"node_modules".to_string()));
        assert!(patterns.contains(&"dist".to_string()));
        assert!(patterns.contains(&".cache".to_string()));
        assert!(patterns.contains(&".temp".to_string()));

        // Should NOT include file patterns
        assert!(!patterns.iter().any(|p| p.contains(".log")));
        assert!(!patterns.iter().any(|p| p.contains(".env")));

        // Should NOT include protected directories
        assert!(!patterns.contains(&".git".to_string()));
        assert!(!patterns.contains(&"src".to_string()));
    }

    #[test]
    fn test_cleanable_dirs_with_gitignore() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        // Create a Node.js project
        fs::write(project_dir.join("package.json"), "{}").unwrap();

        // Create a .gitignore with custom patterns
        let gitignore_content = r#"
node_modules/
dist/
.custom-cache/
"#;
        fs::write(project_dir.join(".gitignore"), gitignore_content).unwrap();

        let cleanable = ProjectDetector::cleanable_dirs_with_gitignore(
            ProjectType::NodeJs,
            project_dir
        );

        // Should include default Node.js patterns
        assert!(cleanable.iter().any(|d| d == "node_modules"));
        assert!(cleanable.iter().any(|d| d == ".next"));

        // Should also include .gitignore patterns
        assert!(cleanable.iter().any(|d| d == "dist"));
        assert!(cleanable.iter().any(|d| d == ".custom-cache"));
    }

    #[test]
    fn test_parse_gitignore_no_file() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path();

        let patterns = ProjectDetector::parse_gitignore(project_dir);
        assert!(patterns.is_empty());
    }

    #[test]
    fn test_is_cmake_build_dir_out_of_source() {
        let temp = TempDir::new().unwrap();
        let build_dir = temp.path().join("mybuild");
        fs::create_dir(&build_dir).unwrap();

        // Create CMakeCache.txt (build artifact)
        fs::write(build_dir.join("CMakeCache.txt"), "# CMake cache").unwrap();

        // Should be recognized as cleanable build directory
        assert!(ProjectDetector::is_cmake_build_dir(&build_dir));
    }

    #[test]
    fn test_is_cmake_build_dir_in_source() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path().join("myproject");
        fs::create_dir(&project_dir).unwrap();

        // Create both CMakeLists.txt (source) and CMakeCache.txt (build)
        // This indicates in-source build - should NOT be deletable
        fs::write(project_dir.join("CMakeLists.txt"), "project(test)").unwrap();
        fs::write(project_dir.join("CMakeCache.txt"), "# CMake cache").unwrap();

        // Should NOT be recognized as cleanable (source + build mixed)
        assert!(!ProjectDetector::is_cmake_build_dir(&project_dir));
    }

    #[test]
    fn test_is_cmake_build_dir_no_cache() {
        let temp = TempDir::new().unwrap();
        let dir = temp.path().join("somedir");
        fs::create_dir(&dir).unwrap();

        // Directory without CMakeCache.txt
        assert!(!ProjectDetector::is_cmake_build_dir(&dir));
    }

    #[test]
    fn test_is_cmake_build_dir_source_only() {
        let temp = TempDir::new().unwrap();
        let project_dir = temp.path().join("myproject");
        fs::create_dir(&project_dir).unwrap();

        // Only source file, no build artifacts
        fs::write(project_dir.join("CMakeLists.txt"), "project(test)").unwrap();

        // Should NOT be recognized as cleanable (source only)
        assert!(!ProjectDetector::is_cmake_build_dir(&project_dir));
    }
}
